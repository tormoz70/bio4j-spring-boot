## Стратегия ветвления версий
#####0. Настройки
 - установить maven (last)
 - в IDEA настроить путь на свой maven
 - скопировать settings.xml (в корне текущего проекта) в $maven_home/conf  

#####1. Версия  
 \<major>.\<minor>.\<fix>  
 _\<major>_ - изменяется если делаем глобальные изменения, которые не поддерживают обратную совместимость и требуют глобальных изменеий в прикладных модулях  
 _\<minor>_ - изменяется если делаем изменения, которые поддерживают обратную совместимость и не требуют глобальных изменений в прикладных модулях  
 _\<fix>_ - изменения которые фиксят какие-то баги  

#####2. Мастер ветка  
Это ветка с именем master-v\<major>.\<minor>  
в этой ветке меняются только версии \<fix>    
Если меняется \<major> или \<minor>, тогда создется новая ветка с именем "master-v\<major>.\<minor>" и далее релизы делаются в ней

#####3. Пример обработки задачи "FIX-62" - Поправить баг
#####_3.1. Ветвимся от нужной ветки (например от ветки origin/master-v2.1 создаем ветку FIX-62)_
```
# git checkout origin/master-v2.1 // переходим в ветку, в которой хотим сделать изменения
# git pull // забираем с сервера последние изменения и устанавливаем на них указатель HEAD
# git checkout -b FIX-62 // создаем новую вертку с именем как у задачи
```
далее работаем в этой ветке, делаем сколько угодно комитов с описанием какие нужны для работы,  
но последний комит обязательно должен быть с опсианием вида "\<номер задачи>: \<имя задачи>" (например: "FIX-62: Поправить баг")  

#####_3.2. Перед тем как сделать merge в основную вертку..._
Перед тем как сделать "merge" в основную верку, необходимо перенести рабочую ветку на последний комит той ветки, в которую собираетесь мержиться, 
т.е. сделать rebase рабочей ветки на последний комит master'a.
```
# //- Замечание! Лучше не использовать merge в рабочую ветку и из нее (если нужно обновить, то делаем rebase)
 1 # git commit -m 'FIX-62: Поправить баг' //- комитим все изменения в ветке FEATURE, 
    которые есть на текущий момент (при желании можно сделать squash, это упростит последующий rebase)
 2 # git push //- все локальные комиты ветки FIX-62 отправляем на сервер, на всякий случай
 3 # git log -15 --graph --oneline //- просматриваем комиты в найше рабочей верке FIX-62
 4 # git rebase -i HEAD~5 //- если много левых комитов (например, их 10), 
    то делаем интерактивный rebase (с этим лучше потренироваться на кроликах,
    перед тем как начинать лучще сделать копию всей папки с проектом)
 5 # git push --force //- после объединения комитов делаем насильный пуш, 
    иначе просто не запушится, т.к. мы убили кучу комитов, которые уже есть на сервере
 6 # git checkout master-v2.1 //- переходим в основную ветку (эта ветка меняется пока вы работаете в своей ветке, 
    поэтому ее надо регулярно обновлять, либо можно это сделать перед самым окончанием работ, 
    зависит от того нужны ливам в вашей ветке новые комиты из основной ветки)
 7 # git pull //- обновляем ветку master-v2.1
 8 # git checkout FIX-62 // возвращаемся в рабочую ветку
 9 # git log -15 --graph --oneline //- просматриваем дерево комитов
10 # git rebase master-v2.1 //- переносим нашу рабочую ветку на обновленную основную ветку.
    При этом все изменения из новых комитов основной ветки попадут в нашу рабочую ветку
    если будут конфликты, то их придется рзрешить ручками
11 # git push --force //- насильный пуш обязательный, т.к. на сервере ваша ветка содержит совсем другие комиты и 
    их нужно перезаписать
```
_по идее пункты 4,5 можно опустить если не нужно объединять комиты_  
далее делаем PULL REQUEST на сервере GITLAB  (todo: это опишу чуть позже)

#####4. Релиз  
Для релиза перейти в основную ветку (например в master-v2.1), выполнить следующие команды:
```
mvn release:prepare -Darguments="-DskipTests -Dmaven.javadoc.skip=true"
mvn release:perform -Darguments="-DskipTests -Dmaven.javadoc.skip=true"
```
